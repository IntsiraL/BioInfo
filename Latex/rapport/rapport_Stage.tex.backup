\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage{amsmath}
\usepackage{stackengine}
\usepackage{setspace}
\usepackage[hyphens]{url}
\usepackage{color}
\usepackage{pdfcolmk}
\usepackage{Sweave}
\usepackage{graphicx}
%\usepackage{placeins}

\newcommand\tabA[1][0.5cm]{\hspace*{#1}}
\newcommand\tabB[1][1.5cm]{\hspace*{#1}}
\newcommand\tabC[1][2cm]{\hspace*{#1}}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

% Title Page
\begin{document}
\begin{titlepage}
  \begin{sffamily}
  \begin{center}

    % Upper part of the page. The '~' is needed because \\
    % only works if a paragraph has started.
 \begin{center}
 \includegraphics{./image/ualogo.png}
 % ualogo.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
\end{center}

    \textsc{ UNIVERSIT\'{E} D'ANGERS \\ UFR INFORMATIQUE}\\[0.5cm]
    \textsc{ \\ Rapport de stage \\ Master 1 2016-2017 }\\[1.5cm]
    
    \includegraphics{./image/logo-generique-SD.png}
    
    \textsc{UMR INSERM 1232 \\-Equipe Immunité Innée et Immunothérapie}\\[1cm]
     
    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries ANALYSE TRANSCRIPTOMIQUE\\[0.4cm] }

    \HRule \\[2cm]
    \centering\vspace*{\fill}
    \begin{minipage}{9\textwidth}
    \begin{doublespace}
    \begin{tabular}{cl}
       \large Présenté par : &\tabC \tabA \textsc{RASOLONIAINA Marlino}\\
       \newline
       \emph{Maître de stage  :} &\tabC \tabA Dr. \textsc{Valérie Seegers}\\
       \emph{Responsable d'équipe : } &\tabC \tabA Dr.  \textsc{Yves Delneste} \\
       
    \end{tabular}
     \end{doublespace}
    \emph{Laboratoire d'accueil :} \tabC \tabA \textsc{INSERM U1232}-Equipe 7
    \\\tabC \tabC \tabC \tabA Bâtiment IRIS 
    \\\tabC \tabC \tabC \tabA CHU-4,rue Larrey 
    \\\tabC \tabC \tabC \tabA 49933 ANGERS
    \end{minipage}
    \vspace*{\fill}
     % Author and supervisor
%      \begin{minipage}{0.4\textwidth}
%        \begin{flushleft} \large
%          \large Présenté par : \\\textsc{RASOLONIAINA Marlino}
%        \end{flushleft}
%      \end{minipage}
%      \begin{minipage}{0.4\textwidth}
%        \begin{flushright} \large
%          \emph{Maître de stage  :} Dr. \textsc{Valérie Segers}\\
%          \emph{Responsable d'équipe : } Dr.  \textsc{Yves Delneste}
%        \end{flushright}
%      \end{minipage}
%  
%      \vfill

    % Bottom of the page
    {\large 12 Avril 2017 — 20 Juin 2017}

  \end{center}
  \end{sffamily}
\end{titlepage}
\newpage
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\DefineVerbatimEnvironment{Sinput}{Verbatim}{formatcom = {\color[rgb]{0, 0, 0.56}}}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{formatcom = {\color[rgb]{0.56, 0, 0}}}
%\section{INTRODUCTION }

\section{PR\'{E}SENTATION DE L'ORGANISME D'ACCUEIL }
\subsection{Organisme d’accueil : Centre de Recherche en Cancérologie et Immunologie Nantes Angers (CRCINA)}
Le CRCINA est une structure de recherche intégrée aux universités de Nantes et d’Angers et labellisée par l’Institut National de la Santé et de la Recherche Médicale (Inserm). 
Le CRCINA regroupe environ 400 personnes dont environ 150 chercheurs et enseignants/chercheurs\footnote{\url{http://www.crcina.org/}}.

Le CRCINA développe des programmes multidisciplinaires alliant recherche fondamentale et clinique, principalement dans le domaine de l’oncologie. Il est organisé autour de trois départements :
\begin{itemize}
 \item le département \textgravedbl Immunologie et Immunothérapie \textacutedbl  regroupe 8 équipes dont les travaux se focalisent sur l’étude de l’immunité cellulaire humaine antitumorale et antivirale et sous un angle plus appliqué sur la mise en oeuvre de protocoles d’immunothérapie passive ou active
\item le département \textgravedbl Oncogénèse et Thérapies Ciblées \textacutedbl
\item le département \textgravedbl Ciblage immunospécifique des radionucléides et radiobiologie \textacutedbl 
\end{itemize}
Les équipes de recherche sont installées sur différents sites : CHU de Nantes, CHU d’Angers et Institut de Cancérologie de l’Ouest (site Gauducheau à Nantes et site Papin à Angers).
Les activités de recherche sont adossées à des plateformes technologiques et plateaux techniques localisés dans les différents sites ; ces laboratoires sont, pour la plupart, intégrés dans les structures fédératives de recherche des sites Santé des Universités de Nantes et d’Angers (SFR Bonamy à Nantes ; SFR ICAT à Angers).
\subsection{Service du rattaché : Équipe 7 de l’U1232 Immunité innée et immunothérapie}
Le système immunitaire est organisé autour de deux composantes, le système immunitaire inné et le système immunitaire adaptatif. Le système immunitaire inné est spécialisé dans la détection des signaux de danger, qu’ils soient d’origine endogène (le soi modifié), représenté par les cellules mortes, ou d’origine exogène (le non soi), à savoir les microbes. 
Toute altération du système immunitaire inné peut avoir des conséquences pathologiques sévères, pouvant aller du déficit immunitaire aux maladies inflammatoires chroniques. Ainsi, les cellules myéloïdes (monocytes, macrophages…) jouent un rôle essentiel dans la réponse immunitaire. Elles sont impliquées dans l’élimination des microbes et des cellules mortes ainsi que dans l’initiation et la polarisation des réponses immunitaires adaptatives. 

Un des objectifs de l’unité est de comprendre les mécanismes cellulaires et moléculaires impliqués dans la polarisation fonctionnelle des macrophages et identifier des stratégies immunothérapeutiques ciblant les macrophages associés aux tumeurs (cf projet d’équipe au point suivant). 
Pour explorer la polarisation des macrophages, l’équipe a utilisé la technologie des puces à ADN pour comprendre les mécanismes d’expression géniques mobilisés par les macrophages en conditions physiologiques particulières (Acide Lactique) par analogie avec un milieu tumoral. 
\section{PR\'{E}SENTATION DU SUJET DE STAGE }
\subsection{Projet d’équipe où s’inscrit le stage :}
Les macrophages sont des cellules d’origine myéloïde présentes dans tous les tissus.
Principalement connus pour leur activité de sentinelles immunitaires impliquées dans l’élimination des microbes, les macrophages sont également impliqués dans le maintien de l’homéostasie et le métabolisme tissulaire. Différentes sous-classes de macrophages ont été définies pour décrire cette diversité fonctionnelle. 
\begin{itemize}
 \item Les macrophages de type M1 sont impliqués dans la réponse anti-microbienne et sont caractérisés par un profil pro-inflammatoire 
\item Les macrophages de type M2 sont impliqués dans la réparation tissulaire et sont caractérisés par un profil anti-inflammatoire. 
\item Il est actuellement admis que ces deux sous-types de macrophages représentent les extrêmes d’un continuum de cellules \cite{sica2012macrophage}.
\end{itemize}
Une des caractéristiques essentielles des macrophages est leur plasticité, c’est-à-dire leur capacité à adopter différents phénotypes en fonction de la nature des signaux reçus localement.
 
Les macrophages jouent un rôle essentiel dans le développement des tumeurs et leur accumulation est, dans la majorité des tumeurs solides, de mauvais pronostic. De nombreuses études ont montré que le statut métabolique de la tumeur est altéré comparativement aux tissus sains, avec notamment une importante glycolyse. Le laboratoire s’est donc intéressé à l’analyse de l’impact de l’acide lactique, métabolite de la glycolyse qui s’accumule en grande quantité dans les tumeurs, et en particulier le cancer de l’ovaire, sur la polarisation fonctionnelle (M1 versus M2) des macrophages humains.
Une étude transcriptomique a donc été réalisée pour analyser l’impact de l’acide lactique sur la différentiation des monocytes en macrophages.
\subsection{Objectif et missions du stage :}
L’étudiant a pu choisir en arrivant entre 3 sujets concernant la question biologique \textgravedbl Impact de l’acide lactique sur la polarisation et l’expression génique des macrophages \textacutedbl (actuellement dans l’unité par 3 doctorants)  avec des puces ADN. Chacun de ces sujets faisait appel à des compétences plus particulières en bioinformatique (informatique/statistiques/biologie) :
\begin{itemize}
 \item Identification de la structure des données brutes issues des puces ADN et étapes de prétraitement des données pour l’analyse différentielle 
\item Analyse différentielle des données des puces 
\item Comment interpréter des résultats de l’analyse différentielle d’une puce ADN 
\end{itemize}
L’objectif est de permettre à l’étudiant de se familiariser avec l’une des étapes du traitement des données d’expression génique,c'est-à dire de l'analyse transcriptomique.
\subsection{Missions réellement réalisées :}
La première partie du projet, donc le premier sujet, a été choisi et réellement réalisée par l’étudiant à partir des données brutes issues de la technologie illumina. 
Il a identifié la structure des données contenues dans ce fichier, et toutes les étapes de contrôle et de prétraitement des données nécessaires aux analyses statistiques ultérieures.
\section{ACQUISITION DES DONN\'{E}ES }

\subsection{ Plan expérimental :}
Le sujet du stage s’inscrit dans la thématique principale du laboratoire qui porte sur l’adaptation du macrophage aux modifications environnementales et plus précisément : l’impact de la présence d’acide lactique (AL), qui s’accumule au sein des tumeurs, sur l’expression génique des macrophages de type M1 (pro-inflammatoires et initiateurs de la réponse immunitaire) et de type M2 (immunotolérants et qui s’accumulent dans les tissus cancéreux).

Pour répondre à cette question, le laboratoire modélise in vitro la polarisation des macrophages en modifiant les conditions de culture des cellules envisageant ainsi 8 conditions expérimentales. (Graphique) Comme il y avait 3 donneurs différents, 24 prélèvements ont été préparés et analysés sur les puces ADN.

Les questions biologiques à explorer sont les suivantes : Quels gènes sont différentiellement exprimés par les macrophages  G (M1) et par les macrophages M (M2) en présence d’acide lactique (AL), en dehors de toute stimulation par LPS ? Avec une stimulation par LPS ? Quels sont les processus biologiques concernés par l’exposition des macrophages à l’acide lactique ? Quelles sont les voies de signalisation concernées ?
\begin{center}
 \includegraphics[scale=0.5]{./image/plan.png}
 % plan.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{Plan éxpérimental }
\end{center}
L’expérience a été faite avec la puce ADN  Illumina HumanHT-12 v4.0 BeadChip 12x1 avec 48210 sondes pour chaque prélèvement.
887 de ses sondes sont classés comme des sondes de contrôles.
On se trouve donc avec 47323 individus sur 24 variables. 
Ce qui nous donne une matrice de données de dimension :
\def\tmp{
  \begin{pmatrix}
  a_{11} & \cdots & a_{1m} \\

   \vdots & \ddots &\vdots \\

   a_{n1} & \cdots & a_{nm} 
 \end{pmatrix}
}
\[
\stackMath\def\stackalignment{r}
  \stackon
    {\mathrm{47323~rows}\left\{\tmp\right.}
    {\overbrace{\phantom{\smash{\tmp\mkern -36mu}}}^{\mathrm{\textstyle 24~columns}}\mkern 20mu}
\]

\subsection{Les puces à ADN :}
  Une puce à ADN est constituée d'un support physique (le plus
  souvent une lame de verre) sur lequel sont déposées des molécules
  d'ADN correspondant à de petits fragments du génome (jusqu'à 40 000
  dépôts différents par puce). On recouvre la puce
  de la solution contenant la population d'ARN à étudier. Les ARN
  s'hybrident sur les fragments d'ADN complémentaires. La quantité d'ARN
  fixée reflète la concentration de cet ARN dans la solution.
  \newline
 Pour des raisons pratiques, on utilise de l’ADN complémentaire plutôt que directement
  l'acide ribonucléique car l’ADN est plus stable. Les ADNc sont marqués par un nucléotide radioactif ou
  un fluorochrome. Il est possible d'étudier simultanément plusieurs
  populations d'ADNc sur une même puce en utilisant des fluorochromes différents.
  La meilleure façon d'utiliser cette possibilité est de marquer
  l'ADN génomique avec un fluorochrome, toujours le même. On
  obtient ainsi une référence stable au cours des années
  qui permet de mettre toutes les puces à la même échelle,
  quelle que soit leur origine. 
  \newline
  Un scanner mesure l'intensité du signal émis par l'ADNc hybridé au niveau de chaque dépôt. Parmi les valeurs que proposent les
  logiciels pour cette intensité, la plus fiable est la médiane de l'intensité des pixels car elle est moins sensible aux défauts de
  l'image (pixels sur-brillants par exemple). 
  \newline
  Les puces comportent généralement plusieurs dépôts identiques pour chaque gène. Cela simplifie le travail lorsqu'il faut
  repérer les aberrations dans la lecture des intensités puisqu'il suffit d'examiner les cas où les valeurs diffèrent beaucoup d'un
  dépôt à l'autre. Il s'agit le plus souvent d'un défaut physique sur la puce et il est facile d'éliminer la valeur aberrante.
  Dans le doute, on conserve la médiane des différentes mesures. 
  \newline
  Plusieurs  types  de  puces  à  ADN  
existent selon le support, la nature des fragments fixés à la surface, le mode de fabrication, la 
densité, le mode de marquage des cibles et les méthodes d’hybridation.
On sait que toutes les technologies des puces ADN se basent sur le principe fondamental de l’hybridation complémentaire des brins d’acide nucléique même si leurs techniques se diffèrent largement entre-elles, 
par exemple sur la longueur et la type de la sonde utilisée (cDNA arrays, oligonucleotide array), l’étiquetage et le protocole d’hybridation…
La vraie différence entre ces approches résident sur la précision, la spécificité, la sensibilité et la robustesse de chaque plateforme.
\begin{center}
 \includegraphics[scale=0.5]{./image/principe.jpg}
 % Etapes_d'une_expérience_de_biopuces.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{Principe général d'utilisation des puces ADN }
\end{center}

\subsection{La technologie Illumina :}
Illumina, Inc. est une société américaine qui fabrique et commercialise des systèmes intégrés pour l'analyse de la variation génétique et la fonction biologique, 
notamment des gammes de produits et services qui servent les marchés du séquençage, génotypage et expression génétique.
\newline
Une de ces récentes fabrications est la puce ``BeadArray technologie''\footnote{\url{https://www.illumina.com/technology/beadarray-technology.html}}.
\begin{center}
 \includegraphics[scale=0.5]{./image/beadarray.png}
 % beadarray_multi_sample_array_formats_lg.gif: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{Illumina BeadArray Technologie }
\end{center}
Dans l’analyse des expressions des gènes, Illumina utilise deux approches différentes : l’hybridation directe (Direct Hybridization assay)\footnote{\url{https://support.illumina.com/array/array\_kits/humanht-12\_v4\_expression\_beadchip\_kit/training.html}} et le DASL (cDNA-mediated Annealing Selection Extension and Ligation).
L’expérience est faite avec la première approche qui consiste à utiliser un simple brin de la séquence d’ADN (pour chaque sonde). Cette séquence monocaténaire s’hybride avec la séquence cible étiquetée dans l’échantillon. 
La quantité du signal fluorescent produit détermine la quantité de l’ARN cible dans l’échantillon.
\begin{center}
 \includegraphics[scale=0.5]{./image/Direct_Hyb.png}
 % direct_hybridization_assay_workflow_lg.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{An Illumina Direct Hybridization probe }
\end{center}
\begin{center}
 \includegraphics[scale=0.5]{./image/direct_hybridization_assay_workflow.png}
 % direct_hybridization_assay_workflow.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{ Direct Hybridization assay workflow}
\end{center}

\subsection{Les sources de variations et les défis sur l'utilisation des puces ADN :}

En Biologie,si on effectue à plusieurs reprises une même expérience, on peut se heurter à des valeurs d’expérience légèrement différentes à chaque exécution.
Il est de ce fait très intéressant de voir de plus près les grandes étapes et les effets des processus biologiques qui sont derrières ces sources de quantité de variabilité dans l’étude des expressions génomique avec les puces ADN.
De ce point de vue, ces variations sont considérées comme des bruits dans la phase d’analyse des expressions.\\
Est-ce que la variation d’un gène particulier est due au bruit de fond de la puce ou c’est réellement une différence entre les conditions expérimentales? C’est là le vrai defi. 
Si on prend un gène spécifique, combien de quantité de sa valeur représente la mesure de la variance due à la régulation des gènes et due à la quantité de bruit ?
Ces sources de variation (Tableau :~\ref{Sources de variation}\cite{miller2002optimal,wildsmith2001research}) nous mènent aux problèmes de fiabilité et de reproductibilité dans les mesures des puces ADN. %qui sont souvent négligés.
Néanmoins, une grande partie de la variabilité induite par la puce elle-même  peut être déterminée à l'aide des techniques 
de réplications ou d’autres techniques de séparations des bruits (Exemples : conception d’expérience statistique, normalisation des données).
Plusieurs efforts ont été menés pour évaluer la fiabilité, la précision et la reproductibilité des puces ADN, inclus des projets comme MAQC(MicroArray Quality Control\cite{shi2006microarray}). \\

\begin{table}[!ht]
\centering
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
 \emph{Facteur} & \emph{Commentaires}\\
\hline
Préparation des mRNA  &  Tissus, les kits et les procedures variantes \\
\hline 
Transcription & Les variations inhérentes dans la réaction, le type de l'enzymes utilisé  \\
\hline 
L'étiquetage (Labeling) & Depend du type,des procédures et l'âge de l'étiquette  \\
\hline
Amplification (PCR) & Il est difficille de quantifier le rendement de la PCR\\
\hline
Variations géométriques des broches & différentes surfaces et propriétés dues à des erreurs aléatoires de production \\
\hline
Volume de l'échantillon & fluctue stochastiquement même pour la même broche (pin)  \\
\hline
Fixation de l'échantillon & La fraction de l'ADNc cible (une gouttelette) qui est chimiquement liée à la surface de la diapositive n'est pas prise en compte \\
\hline
 Paramètre d'hybridation &  influencé par plusieurs facteurs comme la temperature,le temps,le buffering \\
\hline
 Hybridation non-spécifique & un ADNc s'hybride avec une sequence qui n'est pas exactement son complémentaire \\
\hline
Réglages de gain & déplace la répartition des intensités de pixels \\
\hline
Limitation de la plage dynamique & Variabilité de la saturation au bas de gamme ou au haut de gamme \\
\hline
Alignement d'image & Les images d'un même BeadArray à diverses longueurs d'onde correspondant à des canaux différents ne sont pas alignées; différents pixels sont considérés pour le même emplacement \\
\hline
 Placement de la grille & le centre de la sonde (spot) n’est pas bien localisé  \\
\hline
 Bruit de fond non-spécifique& Élévation erronée de la moyenne de l'intensité du bruit de fond \\
\hline
Forme de la sonde (spot) & L'intensité des sondes irréguliers sont difficille à segmenter en bruit de fond \\
\hline
 Segmentation & Des contaminants lumineux peuvent ressembler comme un signal(ex: poussière) \\
\hline
 Quantification & la moyenne des pixels, la médiane,... \\
\hline
\end{tabular}
\caption{Sources typiques de fluctuations dans une expérience avec les puces à ADN}
%\caption{Sources of fluctuations in a typical cDNA microarray experiment}
\label{Sources de variation}
\end{table}
%\FloatBarrier
\section{DESCRIPTION DES DONN\'{E}ES }
\subsection{ Décryptage et lecture :}
Après avoir scanné la puce, le scanner iScan d’Illumina exporte et produit des fichiers de sortie (Tableau :~\ref{Fichiers_Sorties}) .
Les fichiers qui contiennent les intensités de chaque sonde (.idat) sont encryptés et d’autres fichiers sont fournis à titre indicatif et de mesure pour l’analyse.\\
\begin{table}[!ht]
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
\emph{File}  & \emph{Description} \\
\hline
 (Serial Number).txt & un fichier qui stocke la positions et l'identité de chaque sonde, qui contient quelques informations sur les paramètres du scanner\\
\hline
Metrics.txt &  un pour chaque BeadChip  et contient des informations récapitulatives sur l'intensité des signals,
la quantité de saturation, la mise au point et l'enregistrement sur l'image (s) de chaque section \\
\hline 
Effective.cfg & fichier de configuration des paramètres du scanner\\
\hline
(Serial Number).sdf & fichier de description des échantillons d'Illumina utilisé pour déterminer les propriétes (positions)
physique d'une section et savoir les sections liées sur chaque échantillons\\
\hline
*.idat & contiennent la moyenne des intensités du signal de chaque sonde \\
\hline
\end{tabular}
\caption{Description des fichiers de sortie}
\label{Fichiers_Sorties}
\end{table}
\newline
Pour la lecture  des fichiers .idat, l’utilisation d’un fichier manifeste qui contient l’ensemble de tout les informations nécessaires concernant la puce est indispensable pour le décryptage : le nom et l’identifiant  des gènes ( Probe\_id, Array\_Address\_Id, Symbol, Barcode), le statut d’une sonde (regular, negative, biotin,...)
Dans la suite logique des choses, Illumina fourni un logiciel payant (GenomeStudio Software\footnote{\url{https://support.illumina.com/content/dam/illumina-support/documents/documentation/software\_documentation/genomestudio/genomestudio-2011-1/genomestudio-gx-module-v1-0-user-guide-11319121-a.pdf}})  qui aide sur le traitement et l'analyse des puces ADN (Genotyping Module, Gene Expression Module, Methylation Module).
\subsection{ Données brutes via Bioconductor :}
Bioconductor est un projet de développement et un ensemble de package (1380 packages en 2017)  gratuit et open source dans l’analyse et la compréhension des données génomiques basé principalement en langage de programmation statistique R.
\\Limma\footnote{\url{https://bioconductor.org/packages/release/bioc/vignettes/limma/inst/doc/usersguide.pdf}} est un des packages (de choix) dans Bioconductor pour l’analyse des expressions génomique des puces  ADN. La function read.idat() de package Limma permet de lire les fichiers idat d’Illumina BeadArray en fournissant en paramètre le fichier manifeste .bgx correspondant à la plateforme d’expression de gène à étudier.
En fait, read.idat () améliore la fonction readIDAT() du package Illuminaio\cite{smith2013illuminaio} en se basant sur les statuts des sondes (régulier, négatif) parce qu’actuellement, il est le seul package R qui est conçu de décrypter et extraire toutes les informations possibles d’un fichier binaire IDAT (encodé en base64) de plateforme BeadArrayd’Illumina.
\\Après la lecture, on obtient un objet de type ElistRaw de limma (Tableau :~\ref{EListRaw}) qui contient les informations qu’on a besoin. 
Il est pratique par la suite de mettre en correspondance les informations liées aux échantillons avec l’objet nouvellement crée, par exemple changer les noms de la colonne de la matrice des intensités.
\begin{table}[!ht]
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
 \emph{E} & matrice des intensité brutes\\
\hline
\emph{other\$NumBeads }   &  matrice de mêmes dimensions que E donnant les nombre de la sonde (bead) utilisées pour chaque valeur d'intensité. \\
\hline 
\emph{other\$STDEV} & matrice de mêmes dimensions que E donnant un écart type ou une erreur standard pour chaque valeur d'intensité.\\
\hline
\emph{genes} & un data.frame des annotations des sondes qui contient des informations extraites du fichier manifeste relatif au type de puce utilisé : Probe\_Id, Array\_Address\_Id, Status
\\
\hline
\end{tabular}
\caption{Contenu de l'objet EListRaw retourné par la fonction read.idat() de limma}
\label{EListRaw}
\end{table}
\subsection{ Contrôle et qualité :}
Par approximation, on peut considérer qu’un signal émis par la puce soit :
\begin{itemize}
 \item la vraie intensité produit par le gène cible
 \item un signal d’une hybridation non-spécifique
 \item un bruit de fond non-spécifique
\end{itemize}
La puce d’Illumina introduit alors des sondes appelées sonde de contrôle pour pouvoir mesurer et quantifier la qualité des données obtenues.
Avec ces sondes de contrôles, on peut quantifier les bruits et la qualité du signal, vérifier la qualité de la mesure d’expression de l'ensemble des sondes de la puce. 
Une valeur anormale produit par un seul BeadArray peut compromettre le résultat d’une analyse sur l’ensemble des données. 
Dans ce cas, la solution est de répéter l’expérience ou simplement retirer de l’ensemble des données les échantillons qui présentent des qualités médiocres avant la phase de prétraitement et de l’analyse. (Tableau :~\ref{Control Dyrect  Hyb})
\footnote{\url{https://www.bioconductor.org/packages/release/data/experiment/vignettes/BeadArrayUseCases/inst/doc/BeadArrayUseCases.pdf}}
\footnote{\url{http://dnatech.genomecenter.ucdavis.edu/wp-content/uploads/2013/11/technote\_gene\_expression\_data\_quality\_control.pdf}}.
\begin{table}[!ht]
\centering
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
 Contrôle de spécimen biologique & ces sont des gènes appelés ‘housekeeping genes’ qui doivent être exprimés dans tous les échantillons\\
\hline
Contrôle de l’étiquetage des échantillons (Labeling)   &  des ARN spécifiques(lysA,pheA,thrB,trpF) sont introduits dans les échantillons juste avant la transcription inverse (cDNA) et l’étiquetage. Des faibles signaux provenant de ses sondes indiquent des éventuelles problèmes lors de la réaction \\
\hline 
Contrôle de l’hybridation & 
\begin{itemize}
 \item Cy3-labeled hyb : ce contrôle se compose de 6 sondes d’oligonucléotides marqué par le fluorochrome Cy3 avec trois concentrations (low, medium, high) et doit produire des signaux progressivement croissants.
 \item Low-stringency hyb: ce contrôle de stringence d’hybridation se compose de 8 sondes (medium, high) avec exception que chaque sonde contient deux bases mésappariés  (Perfect Match \& Mismatch )
 \item High-stringency hyb
\end{itemize}
\\
\hline
Contrôle de génération des signaux & des ARN sont marqués par de la biotin. On attend un signal d'hybridation positif provenant de ces sondes\\
\hline
Contrôle de sonde négative & des centaines de sondes de séquences aléatoires sans cibles dans le génome sont intégrées dans la puce reflétant les signaux de bruit de fond du système d'imagerie,d'hybridation croisée et autres.On s'attend à des faibles signaux provenant de ces sondes. \\
\hline
\end{tabular}
\caption{Liste des contrôles des données d'Illumina BeadArray}
\label{Control Illumina}
\end{table}

\begin{table}[!ht]
\centering
\begin{tabular}{|p{3cm}|p{9cm}|}
\hline
 \emph{Contrôle} & \emph{Valeurs attendues}\\
\hline
Hybridization Controls*   &  High > Medium > Low \\
\hline 
Low Stringency* & PM > MM2\\
\hline
Biotin and High Stringency* & valeurs élevées\\
\hline
Negative Controls (Background and Noise) & valeurs faibles \\
\hline
Gene Intensity (Housekeeping and All Genes) & Plus élevée que les bruits de fond (Housekeeping > All Genes) \\
\hline
Labeling and Background & Labeling >= Background \\
\hline
\end{tabular}
\caption{Contrôle d'hybridation direct de la technologie BeadArray d'Illumina}
\label{Control Dyrect  Hyb}
Les contrôles marqués par (*) sont fortement recommandé par Illumina.
\end{table}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/hybControl.png}
 % hybControl.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Contôle d'hybridation}
 \label{fig:hybControl}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/LowStringency.png}
 % LowStringency.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Low Stringency control}
 \label{fig:lowStringency}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/SummaryControl.png}
 % SummaryControl.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Résume de l'ensemble de contôle d'hybridation direct de la technologie BeadArray d'Illumina}
 \label{fig:summaryControl}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/signal_to_noise.png}
 % signal_to_noise.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Rapport signal-bruit sur les deux puces}
 Un rapport signal/bruit (SNR) peut être calculé en utilisant les mesures fournies par le scanner (dans le fichier metrics.txt) incluant les 95(P95) et 5(P05) quantiles de toutes les intensités de pixels de  l’image de chaque section. 
 Ces informations de mesures dépendent du paramètre de scanner et sont tout aussi utile pour l’évaluation de la qualité des données des échantillons ou bien pour évaluer si des échantillons semblent être des valeurs aberrantes. 
 Illumina recommande que le ratio SNR soit supérieur à 10 pour les puces HT-12.
 \label{fig:SNR}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/Detectedgenes.png}
 % Detectedgenes.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Nombre des genes detectés sur chaque échantillon}
 \label{fig:detectedGene}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/outliers.png}
 % Outliers.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Détection des valeurs abérrantes}
 \label{fig:outliers}
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/ratiopmmm2.png}
 % ratiopmmm2.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{Rapport PM/MM2}
 \label{fig:pmmm2ratio}
 Certains échantillons présentent une divergence de ratio : entre P1\_M et P2\_G pour la première puce, et l’échantillon P3\_MALLPS pour la deuxième puce.
\end{figure}
\begin{figure}
 \centering
 \includegraphics[scale=0.5]{../../R/output/propexpr.png}
 % propexpr.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \caption{ Estimation de proportion des sondes exprimées sur les deux puces avec la fonction propexpr() de limma}
 Ces valeurs ne sont pas vraiment des probabilités, elles estiment la proportion globale de sondes sur chaque section de la puce Illumina BeadChip qui correspondent à des gènes exprimés selon la méthode de Shi et al (2010)\cite{shi2010estimating}.
 $pi1= (pb-p)/(pb-p1) $ avec $(pi1[pi1 > 1] \leftarrow 1 $ et $pi1[pi1 < 0] \leftarrow 0)$\\
 La fonction compare la distribution d’intensité empirique des sondes de contrôle négatif avec celle des sondes régulières. 
 Un modèle de mélange est adapté aux données de chaque échantillon de la puce pour inférer la distribution d’intensité des sondes exprimées et estimer la proportion exprimée.
\label{fig:propexpr}
 \end{figure}
\subsection{ Commentaire des résultats :}
Un premier préavis sur la qualité de notre donnée est indiqué par le rapport signal/bruit( Figure ~\ref{fig:SNR}).\\
\begin{Schunk}
\begin{Sinput}
#########################################
 summary(ht12snr)#Signal -to-noise  ratio  for  200729890044  data
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  6.968   9.290   9.775   9.886  10.520  12.920 
\end{Soutput}
\begin{Sinput}
 summary(ht12snrB)#Signal -to-noise  ratio  for  200796240064  data
\end{Sinput}
\begin{Soutput}
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  7.841   8.817   9.561   9.813  11.050  11.570 
\end{Soutput}
\begin{Sinput}
 sd(ht12snr)
\end{Sinput}
\begin{Soutput}
[1] 1.628862
\end{Soutput}
\begin{Sinput}
 sd(ht12snrB)
\end{Sinput}
\begin{Soutput}
[1] 1.317086
\end{Soutput}
\end{Schunk}

Les valeurs SNR minimumes respectivement pour la puce 44 et 64 sont $6.968$ et $7.871$. Ces chiffres sont inférieurs à la valeur préconisée par Illumina mais en moyenne, on voit que la moitie des échantillons sur chaque puce a un SNR aux alentours de 10. Les valeurs ne sont pas très critiques.
\\En examinant la figure \ref{fig:summaryControl}, on trouve pas des anomalies particulières sur l’ensemble des contrôles. On voit que les  housekeeping genes produisent des signaux presque 100 fois plus fort que les sondes négatives ($12000 > 120$).
La proportion des valeurs aberrantes sur chaque échantillon reste faible (Figure \ref{fig:outliers}). 
Pour la figure \ref{fig:pmmm2ratio}, la divergence de ratio trouvée indique une différence possible de stringence d’hybridation entre les échantillons concernés (problème de spécificité dans l’expérience). \\
Tous les échantillons préparés à partir de la même source d’échantillon devraient avoir un nombre similaire de transcrits détectés, c'est un peu le cas dans la figure \ref{fig:detectedGene}.
L’écart type de l’estimation de la proportion des sondes exprimés sur l’ensemble des échantillons n’est pas énorme ($sd(propexpr(obj))=0.03361209$) par rapport à la moyenne($mean(propexpr(obj))=0.4087041$), donc la variation de la dite proportion entre les échantillons n'est pas signifiante.
\\En somme, il n’y a pas un facteur discriminatoire sur l’ensemble des contrôles effectués qui peut ne pas valider les données en termes de qualité. Toutefois, la phase de prétraitement doit tenir compte de quelque spécificité liée à la qualité (Exemple : le fait qu’on a deux puces,...) pour mener à bien l'analyse.
\section{PR\'{E}TRAITEMENT DES DONN\'{E}ES }
\subsection{Correction de bruit de fond :}
\subsection{Transformation :}
La distribution du niveau d'expression des gènes est très asymétrique avec un petit nombre de valeurs élevées. C’est une source de problèmes, car de nombreuses méthodes statistiques supposent implicitement une distribution gaussienne. 
Un simple calcul d’écart type ne satisfait donc pas de donner une interprétation habituelle de la distribution. La transformation logarithmique est la plus utilisée. 
\\Il y a plusieurs avantages d’utiliser la transformation logarithmique. Les données transformées sont plus faciles à interpréter (avec la variation du niveau d’expression des gènes plus réaliste) et aussi plus signifiantes de point de vue biologique (les intensités sont généralement comprises entre 0 et 65 535). 
L’asymétrie est fortement diminuée et la transformation  rend la distribution du niveau d’expression des gènes presque normale(distribution gaussienne).
Après transformation, les conditions d'application des méthodes et des tests statistiques sont mieux satisfaites. 
\subsection{Normalisation :}
Il n’est pas très judicieux de se lancer tout de suite à la comparaison et l’analyse des expressions des gènes à partir des échantillons multiples, car des sources parasites de variations des expressions peuvent fausser le résultat, exemples :quantité d’ARN différentes dans les échantillons, efficacité de la détection 
de fluorescence, biais systématiques, artefacts, conditions d’hybridation des échantillons.
Parmi ces sources, on cible plus précisément :
\begin{itemize}
 \item \emph{l’hétérogénéité du bruit de fond} :
 Si le bruit de fond présente des variations très différentes d’une puce à une autre, ou très structurées spatialement sur une puce, alors on peut être amené à corriger le signal par soustraction du bruit de fond. 
 \item \emph{l’hétérogénéité du signal} :
 De la même manière, le principe d’invariance d’une très grande majorité des expressions géniques d’une puce à une autre doit se traduire par une répartition comparable des valeurs des signaux entre les différentes puces. Si des différences marquées existent, il est judicieux de ramener les signaux moyens de chaque puce à la même valeur.
\end{itemize}
Avant de s’approcher des hypothèses favorables pour l’analyse différentielle, la normalisation est nécessaire afin de s’assurer que les données des différentes puces sont exploitables et comparable entre elles, que les différences d’intensité sont en effet dues à l’expression différentielle et non aux artefacts et les biais techniques expérimentaux.
Il y a plusieurs méthodes de normalisation\cite{bolstad2003comparison} souvent classé en deux catégories :
\begin{itemize}
 \item \emph{méthodes qui utilisent des données de référence (baseline array)}: méthode de mise à l'echelle (Scaling methods) et les méthodes non-linéaire (Non-linear methods)
 \item \emph{méthodes qui combinent l’information de toutes les sections de la puce dans un ensemble de données donné (méthode complet)}: Lowess,normalisation par quantile,RMA(Robust Multi-Array Analysis)
\end{itemize}

% \subsection{Filtrage :}
\subsection{La fonction neqc() du package Limma :}
Le package Limma (écrit par Gordon Smyth,Matthew Ritchie et autres) contient pas mal de fonction de normalisation de puce à ADN que ce soit à une ou double couleur. Mais la fonction qui nous intéresse est la fonction neqc() spécialement personnalisée pour les puces Illumina BeadChips.
Cette fonction R effectue avant la transformation logarithmique des données une correction de bruit de fond utilisant des sondes de contrôle négatif suivie après par la normalisation par quantile utilisant à la fois les sondes de contrôle positif et négatif.
\\L’algorithme utilise le modèle \textgravedbl normexp \textacutedbl\cite{silver2009microarray} pour la correction de bruit de fond qui consiste à modéliser les intensités de pixels observées en tant que somme de deux variables aléatoires, une normalement distribuée et l’autre répartie exponentiellement, représentant respectivement le bruit et le signal de fond. 
La moyenne (\emph{mu}) et l’écart-type (\emph{sigma}) du bruit de fond normalement distribuée du modèle normexp sont estimés avec les valeurs des sondes de contrôle négatif et  la moyenne (\emph{alpha}) du signal répartie exponentiellement est estimée comme la différence entre la moyenne du signal et la moyenne des sondes de contrôle négatif.
\begin{scriptsize}
 \\$mu \leftarrow colMeans(xn, na.rm = TRUE)$
 \\$sigma \leftarrow sqrt(rowSums((t(xn) - mu)^2, na.rm = TRUE)/(nrow(xn) - 1))$
 \\$alpha \leftarrow pmax(colMeans(xr, na.rm = TRUE) - mu, 10)$
 \\$mu.sf \leftarrow x - mu - sigma^2/alpha$
 \\$signal \leftarrow mu.sf + sigma^2 * exp(dnorm(0, mean = mu.sf, sd = sigma, log = TRUE) - pnorm(0, mean = mu.sf, sd = sigma, lower.tail = FALSE, log.p = TRUE))$
\end{scriptsize}
\\Après la correction, un petit décalage (offset) est ajouté (par défaut 16) aux intensités corrigées pour  améliorer la performance dans la phase d’analyse d’expression différentielle et on applique la normalisation par quantile(\emph{normalizeBetweenArrays}).
Le but de la normalisation par quantile est de mettre la distribution, médiane et la moyenne des intensités des sondes de chaque puce sur le même niveau pour toutes les échantillons. Ceci est fait de façon suivante :
\begin{enumerate}
 \item Donner la matrice des intensités $X$ de dimensions $p * n$ avec les colonnes représentent les échantillons et les lignes représentent les sondes
\item Trier chaque colonne de X par ordre croissant pour construire $X_{sort}$
\item Calculer la moyenne par ligne de $X_{sort}$ et affecter cette moyenne sur chaque élément dans la ligne pour avoir $X_{sm}$
\item Construire $X_{normalized}$ en réarrangeant  les éléments de chaque colonne de Xsm dans l’ordre de la matrice  original $X$
\end{enumerate}
\begin{center}
 \includegraphics[scale=0.5]{../../R/output/boxplotbeforeNorm.png}
 % boxplotbeforeNorm.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{ Box plot des signaux avant normalisation}
\end{center}
\begin{center}
 \includegraphics[scale=0.5]{../../R/output/boxplotAfterNorm.png}
 % boxplotbeforeNorm.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{ Box plot des signaux après normalisation}
\end{center}
\begin{center}
 \includegraphics[scale=0.5]{../../R/output/Densitypop1.png}
 % Densité_pop1.png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{ Densité de la population 1 avant la normalisation}
\end{center}
\begin{center}
 \includegraphics[scale=0.5]{../../R/output/Densitypop1C.png}
 % Densité_pop1(correct).png: 0x0 pixel, 300dpi, 0.00x0.00 cm, bb=
 \captionof{figure}{ Densité de la population 1 après la normalisation}
\end{center}

%\section{ANALYSE DES DONN\'{E}ES DE TRANSCRIPTOME :}
% \subsection{Gènes différentiellement exprimés :}
% \subsection{Gènes co-exprimés :}
%=> En cours
%\section{INTERP\'{E}TATION :}
%=> Pas de temps
% (Caractérisation d’un ensemble de gènes)
\section{CONCLUSION :}
\section{ANNEXE: Scripts R développés et quelques fonctions de Limma}
\subsection{Lecture des fichiers IDAT :}
\begin{Schunk}
\begin{Sinput}
 require(limma)
 idatfilesPath<-getwd()
 idatFiles44 <- list.files(paste(idatfilesPath,"/../Data/200729890044/",sep = ""),
                           all.files=FALSE,pattern=".idat")
 idatFiles64 <- list.files(paste(idatfilesPath,"/../Data/200796240064/",sep = ""),
                           all.files=FALSE,pattern=".idat")
 bgxfile=paste(idatfilesPath,"/../Data/HumanHT-12_V4_0_R2_15002873_B.bgx",sep = "")
 controlProfil  <- read.table(paste(idatfilesPath,"/../Data/controlProfil.txt",sep = ""), 
                              sep = "\t", header = TRUE ,as.is = TRUE)
 idatFiles = c()
 for (i in idatFiles44){
   idatFiles <- c(idatFiles,paste(idatfilesPath,"/../Data/200729890044/",i,sep = ""))
 }
 for (i in idatFiles64){
   idatFiles <- c(idatFiles,paste(idatfilesPath,"/../Data/200796240064/",i,sep = ""))
 }
 #lectures des fichiers idat par ordre alphabétique des noms des fichiers avec 
			    read.idat de limma
 obj<-read.idat(idatFiles, bgxfile, dateinfo=TRUE,annotation = "Symbol",tolerance=0L, 
			    verbose = TRUE)
\end{Sinput}
\begin{Soutput}
Reading manifest file ../Data/HumanHT-12_V4_0_R2_15002873_B.bgx ... Done
	 ../Data/200729890044/200729890044_A_Grn.idat ... Done
	 ../Data/200729890044/200729890044_B_Grn.idat ... Done
	  ....................................................
	 ../Data/200796240064/200796240064_K_Grn.idat ... Done
	 ../Data/200796240064/200796240064_L_Grn.idat ... Done
Finished reading data.
\end{Soutput}
\begin{Sinput}
 #renommer les colonnes de la matrice des intensités
 nameCol <- c("P1_G","P1_MAL","P1_GLPS","P1_GALLPS","P1_M","P1_GAL","P1_MLPS","P1_MALLPS")
   for (i in c("","AL","LPS","ALLPS")){
     nameCol <- c(nameCol, paste("P2_G",i,sep = ""))
   }
   for (i in c("","AL","LPS","ALLPS")){
     nameCol <- c(nameCol, paste("P2_M",i,sep = ""))
   }
   for (i in c("","AL","LPS","AL_LPS")){
     nameCol <- c(nameCol, paste("P3_G",i,sep = ""))
   }
   for (i in c("","AL","LPS","ALLPS")){
     nameCol <- c(nameCol, paste("P3_M",i,sep = ""))
   }
 colnames(obj$E) <- nameCol
 colnames(obj$other$NumBeads) <- nameCol
 colnames(obj$other$STDEV) <- nameCol
 #Contrôle de p-values$
 obj$genes$DetectionPValue <- detectionPValues(obj)
 controlData <- obj[obj$genes$Status != "regular",]
 bruteData <- obj[obj$genes$Status == "regular",]
\end{Sinput}
\end{Schunk}
\subsection{Contrôle des données :}
\subsubsection{ Utilisation du fichier Metrics.txt :}
\begin{Schunk}
\begin{Sinput}
 par(mfcol=c(2,1))
 ht12metrics  <- read.table(paste(idatfilesPath,"/../Data/200729890044/Metrics.txt",
 sep = ""),sep = "\t", header = TRUE ,as.is = TRUE)
 ht12snr  <- ht12metrics$P95Grn/ht12metrics$P05Grn
 labs  <- paste(ht12metrics[, 2],  ht12metrics[, 3], sep = "_")
 par(mai = c(1.5, 0.8, 0.3, 0.1))
 plot (1:12 , type = "b",  ht12snr , pch = 19, ylab = "P95 / P05", xlab = "",
 main = "Signal -to-noise  ratio  for  200729890044  data", axes = FALSE ,
 frame.plot = TRUE)
 axis (2)
 axis(1, 1:12, nameCol[1:12] , las = 2)
 abline(h=10, col="red")
 #########################################################
 ht12metricsB  <- read.table(paste(idatfilesPath,"/../Data/200796240064/Metrics.txt",
 sep = ""),sep = "\t", header = TRUE ,as.is = TRUE)
 ht12snrB  <- ht12metricsB$P95Grn/ht12metricsB$P05Grn
 par(mai = c(1.5, 0.8, 0.3, 0.1))
 plot (1:12 ,  ht12snrB ,type = "b", pch = 19, ylab = "P95 / P05", xlab = "",
 main = "Signal -to-noise  ratio  for  200796240064  data", axes = FALSE ,
 frame.plot = TRUE)
 axis (2)
 axis(1, 1:12, nameCol[13:24] , las = 2)
 abline(h=10, col="red")
 par(mfcol=c(1,1))
 #########################################
\end{Sinput}
\end{Schunk}
\subsubsection{Utilisation des données pour le contrôle:}
\begin{Schunk}
\begin{Sinput}
 ###############################################################################
 ###############################################################################
 ############################## CONTROL DATA	################################
 ###############################################################################
 ###############################################################################
 #function to add the error bar representing the confidence interval
 error.bar <- function(x, y, upper, lower=upper, length=0.1,...){
   arrows(x,y+upper, x, y-lower, angle=90, code=3, length=length, ...)
 }
 ###############################################################################
 ## Hybridation controls                                                      ##
 ###############################################################################
 low = c()
 for(i in c(1:24)){
   low <- c(low,mean(controlData$E[controlProfil$Reporter_Group_id==
   "phage_lambda_genome:low",i]))
 }
 medium = c()
 for(i in c(1:24)){
   medium <- c(medium,mean(controlData$E[controlProfil$Reporter_Group_id==
   "phage_lambda_genome:med",i]))
 }
 high = c()
 for(i in c(1:24)){
   high <- c(high,mean(controlData$E[controlProfil$Reporter_Group_id==
   "phage_lambda_genome:high",i]))
 }
 vv <- c(mean(low),mean(medium),mean(high))
 vvSD <- c(sd(low),sd(medium),sd(high))
 names(vv) <- c("Low","Medium", "High")
 par(mfcol=c(2,2))
 hybC_Bar <- barplot(vv,ylim = c(0,1.2*max(vv)), ylab = "Signal",main = 
 "Hybridation Controls")
 error.bar(hybC_Bar,vv, vvSD)
 plot(low, type = "b", ylab = "Signal",xaxt="n", xlab = "",main = 
 "QC Report Hybridation Controls: low")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(medium, type = "b", ylab = "Signal",xaxt="n", xlab = "",main = 
 "QC Report Hybridation Controls: medium")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(high, type = "b", ylab = "Signal",xaxt="n", xlab = "",main = 
 "QC Report Hybridation Controls: high")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 abline(v=12.5, col="red")
 ###############################################################################
 ## Negative controls                                                         ##
 ###############################################################################
 negC <- obj[obj$genes$Status == "negative",]
 background = c()
 for(i in c(1:24)){
   background <- c(background,mean(c(negC$E[,i])))
 }
 noise = c()
 for(i in c(1:24)){
   noise <- c(noise,sd(c(negC$E[,i])))
 }
 nn <- c(mean(background),mean(noise))
 nnSD <- c(sd(background),sd(noise))
 names(nn) <- c("Background", "Noise")
 par(mfcol=c(2,2))
 negC_Bar <- barplot(nn,ylim = c(0,1.2*max(nn)), ylab = "Signal",
 main = "Negative Controls")
 error.bar(negC_Bar,nn, nnSD)
 plot(background, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report background")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(noise, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report noise")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 ###############################################################################
 ## Biotin & High Stringency   | Low Stringency                               ##
 ###############################################################################
 biotC <- obj[obj$genes$Status == "biotin",]
 biot = c()
 for(i in c(1:24)){
   biot <- c(biot,mean(c(biotC$E[,i])))
 }
 #A voir$
 highStingc = rep(55,24)
 mm2 = c()
 for(i in c(1:24)){
   mm2 <- c(mm2,mean(controlData$E[controlProfil$Reporter_Group_id==
   "phage_lambda_genome:mm2",i]))
 }
 pm = c()
 for(i in c(1:24)){
   pm <- c(pm,mean(controlData$E[controlProfil$Reporter_Group_id==
   "phage_lambda_genome:pm",i]))
 }
 ss <- c(mean(biot),mean(highStingc))
 ssSD <- c(sd(biot),sd(highStingc))
 names(ss) <- c("Biotin", "High stringency")
 lss <- c(mean(mm2),mean(pm))
 lssSD <- c(sd(mm2),sd(pm))
 names(lss) <- c("mm2", "pm")
 par(mfcol=c(2,2))
 bhC_Bar <- barplot(ss,ylim = c(0,1.2*max(ss)), ylab = "Signal",
 main = "Biotin & High Stringency")
 error.bar(bhC_Bar,ss, ssSD)
 plot(biot, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report biotin")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(highStingc, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report high stringency")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 par(mfcol=c(2,2))
 lsC_Bar <- barplot(lss,ylim = c(0,1.2*max(lss)), ylab = "Signal",
 main = "Low Stringency")
 error.bar(lsC_Bar,lss, lssSD)
 plot(mm2, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report mm2")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(pm, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report pm")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 ###############################################################################
 ## Gene Intensity                                                            ##
 ###############################################################################
 houseKC <- obj[obj$genes$Status == "housekeeping",]
 housk = c()
 for(i in c(1:24)){
   housk <- c(housk,mean(c(houseKC$E[,i])))
 }
 allge = c()
 for(i in c(1:24)){
   allge <- c(allge,mean(c(bruteData$E[,i])))
 }
 gi <- c(mean(housk),mean(allge))
 giSD <- c(sd(housk),sd(allge))
 names(gi) <- c("Housekeeping genes", "all genes")
 par(mfcol=c(2,2))
 giC_Bar <- barplot(gi, ylim = c(0,1.2*max(gi)), ylab = "Signal",
 main = "Gene Intensity")
 error.bar(giC_Bar,gi, giSD)
 plot(housk, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report Housekeeping")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 plot(allge, type = "b", ylab = "Signal",xaxt="n", xlab = "",
 main = "QC Report gene")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 ###############################################################################
 ## Labeling & Background  | Control Summary                                 ##
 ###############################################################################
 labelC <- obj[obj$genes$Status == "labeling",]
 labl = c()
 for(i in c(1:24)){
   labl <- c(labl,mean(c(labelC$E[,i])))
 }
 #$
 labk <- c(mean(labl),mean(background))
 labkSD <- c(sd(labl),sd(background))
 names(labk) <- c("Labeling","Background")
 par(mfcol=c(3,2))
 hybC_Bar <- barplot(vv,ylim = c(0,1.2*max(vv)), ylab = "Signal",
 main = "Hybridation Controls")
 error.bar(hybC_Bar,vv, vvSD)
 bhC_Bar <- barplot(ss,ylim = c(0,1.2*max(ss)), ylab = "Signal",
 main = "Biotin & High Stringency")
 error.bar(bhC_Bar,ss, ssSD)
 lsC_Bar <- barplot(lss,ylim = c(0,1.2*max(lss)), ylab = "Signal",
 main = "Low Stringency")
 error.bar(lsC_Bar,lss, lssSD)
 negC_Bar <- barplot(nn,ylim = c(0,1.2*max(nn)), ylab = "Signal",
 main = "Negative Controls")
 error.bar(negC_Bar,nn, nnSD)
 giC_Bar <- barplot(gi, ylim = c(0,1.2*max(gi)), ylab = "Signal",
 main = "Gene Intensity")
 error.bar(giC_Bar,gi, giSD)
 lbkC_Bar <- barplot(labk, ylim = c(0,1.2*max(labk)), ylab = "Signal",
 main = "Labeling & Background")
 error.bar(lbkC_Bar,labk, labkSD)
 par(mfcol=c(1,1))
 ###############################################################################
 ## Outliers                 & Missing Value                                  ##
 ###############################################################################
 outliers <- function(i){
   q <- quantile(bruteData$E[,i])
   length(bruteData$E[bruteData$E[,i] > q[4] + 1.5*IQR(bruteData$E[,i]),i])
 }
 abr=c()
 for(i in c(1:24)){
   abr <- c(abr,outliers(i))
 }
 par(mfcol=c(2,1))
 plot(abr, type = "b", ylab = "Number of Genes (Intensity > q3 + 1.5(q3 - q1))",
 xaxt="n", xlab = "",main = " Outliers for Each Sample")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 abline(v=12.5, col="blue")
 plot(abr/nrow(bruteData$E), type = "b", ylab = "NbOutliers/NbGenes",xaxt="n", 
 xlab = "",main = " Outliers for Each Sample")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 abline(v=12.5, col="red")
 #$
 ###############################################################################
 ## Nombre des gènes detecter                                                 ##
 ###############################################################################
 gDetect=c()
 for(i in c(1:24)){
   gDetect <- c(gDetect,length(bruteData$genes$DetectionPValue[bruteData
   $genes$DetectionPValue[,i] < 0.05,i]))
 }
 par(mfcol=c(2,1))
 hybC_Bar <- barplot(mean(gDetect),ylim = c(0,1.5*mean(gDetect)), ylab = 
 "Number of Genes",xlab="All Array",main = "Detected Genes (p-value < 0.05)")
 error.bar(hybC_Bar,mean(gDetect), sd(gDetect))
 plot(gDetect, type = "b", ylab = "Detected Genes (p-value < 0.05)",xaxt="n", 
 xlab = "",main = " Number of Genes Detected for Each Sample")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 abline(v=12.5, col="red")
 par(mfcol=c(1,1))
 ###############################################################################
 ## PM/MM2 Ratio                                                              ##
 ###############################################################################
 plot(pm/mm2, type = "b", ylab = "Ration of PM/MM2 Signals",xaxt="n", xlab = "",
 main = "PM/MM2 Ratio Line Plot")
 axis(1, at=c(1:24), labels = nameCol, las=2)
 abline(h=c(1.8,2.2), col="blue")
 abline(v=12.5, col="red")
\end{Sinput}
\subsubsection{La fonction propexpr() de limma :}
\begin{Sinput}
 propexpr()
\end{Sinput}
\begin{Soutput}
function (x, neg.x = NULL, status = x$genes$Status, labels = c("negative", 
    "regular")) 
{
    if (is.null(neg.x)) {
        ineg <- grep(tolower(labels[1]), tolower(status))
        if (length(labels) > 1) {
            ireg <- grep(tolower(labels[2]), tolower(status))
        }
        else {
            ireg <- -ineg
        }
        x <- as.matrix(x)
        neg.x <- x[ineg, , drop = FALSE]
        x <- x[ireg, , drop = FALSE]
    }
    else {
        x <- as.matrix(x)
        neg.x <- as.matrix(neg.x)
    }
    narrays <- ncol(x)
    p <- pb <- p1 <- rep(NA, narrays)
    for (i in 1:narrays) {
        b <- neg.x[, i]
        b <- b[!is.na(b)]
        nb <- length(b)
        r <- x[, i]
        r <- r[!is.na(r)]
        nr <- length(r)
        mu <- mean(b)
        alpha <- max(mean(r) - mu, 10)
        b1 <- median(b)
        p1[i] <- mean(pexp(b1 - b, rate = 1/alpha))
        pb[i] <- (sum(b < b1) + sum(b == b1)/2)/nb
        p[i] <- (sum(r < b1) + sum(r == b1)/2)/nr
    }
    pi1 <- (pb - p)/(pb - p1)
    pi1[pi1 > 1] <- 1
    pi1[pi1 < 0] <- 0
    names(pi1) <- colnames(x)
    pi1
}
\end{Soutput}
\end{Schunk}
\subsection{Prétraitement des données :}
\begin{Schunk}
\begin{Sinput}
 dCorect <- neqc(obj)
\end{Sinput}
\subsubsection{La fonction neqc() de limma :}
\begin{Sinput}
 neqc
\end{Sinput}
\begin{Soutput}
function (x, status = NULL, negctrl = "negative", regular = "regular", 
    offset = 16, robust = FALSE, detection.p = "Detection", ...) 
{
    x.bg <- nec(x, status, negctrl, regular, offset, robust, 
        detection.p)
    if (is(x.bg, "EListRaw")) {
        y <- normalizeBetweenArrays(x.bg, method = "quantile", 
            ...)
        if (is.null(status)) 
            status <- y$genes$Status
        if (!is.null(status)) {
            y <- y[tolower(status) == tolower(regular), ]
            y$genes$Status <- NULL
        }
    }
    else {
        x.bg <- as.matrix(x.bg)
        y <- log2(normalizeBetweenArrays(x.bg, method = "quantile", 
            ...))
        if (!is.null(status)) 
            y <- y[tolower(status) == tolower(regular), ]
    }
    y
}
\end{Soutput}
\subsubsection{La fonction nec() de limma :}
\begin{Sinput}
 nec
\end{Sinput}
\begin{Soutput}
function (x, status = NULL, negctrl = "negative", regular = "regular", 
    offset = 16, robust = FALSE, detection.p = "Detection") 
{
    if (is(x, "EListRaw")) {
        if (!is.null(x$Eb)) {
            x$E <- x$E - x$Eb
            x$Eb <- NULL
        }
        if (is.null(status)) 
            status <- x$genes$Status
        if (any(tolower(status) %in% tolower(negctrl))) {
            normexp.par <- normexp.fit.control(x, status, negctrl, 
                regular, robust)
        }
        else {
            normexp.par <- normexp.fit.detection.p(x, detection.p)
            message("Note: inferring mean and variance of negative 
            control probe intensities from the detection p-values.")
        }
        for (i in 1:ncol(x)) x$E[, i] <- normexp.signal(normexp.par[i, 
            ], x$E[, i])
        x$E <- x$E + offset
    }
    else {
        x <- as.matrix(x)
        if (any(tolower(status) %in% tolower(negctrl))) {
            normexp.par <- normexp.fit.control(x, status, negctrl, 
                regular, robust)
        }
        else {
            normexp.par <- normexp.fit.detection.p(x, detection.p)
        }
        for (i in 1:ncol(x)) x[, i] <- normexp.signal(normexp.par[i, 
            ], x[, i])
        x <- x + offset
    }
    x
}
#$
\end{Soutput}
\subsubsection{La fonction normexp.fit.control() de limma :}
\begin{Sinput}
 normexp.fit.control
\end{Sinput}
\begin{Soutput}
function (x, status = NULL, negctrl = "negative", regular = "regular", 
    robust = FALSE) 
{
    if (is(x, "EListRaw")) {
        if (is.null(status)) 
            status <- x$genes$Status
        x <- x$E
    }
    x <- as.matrix(x)
    if (is.null(status)) 
        stop("Probe status not found")
    xr <- x[tolower(status) == tolower(regular), , drop = FALSE]
    if (nrow(xr) == 0) 
        stop("No regular probes found")
    xn <- x[tolower(status) == tolower(negctrl), , drop = FALSE]
    if (nrow(xn) < 2) 
        stop("Fewer than two negative control probes found")
    if (robust) {
        if (!requireNamespace("MASS", quietly = TRUE)) 
            stop("MASS package required but is not available")
        narrays <- ncol(xn)
        m <- s <- rep(0, narrays)
        for (j in 1:ncol(xn)) {
            h <- MASS::huber(log(xn[, j]))
            m[j] <- h$mu
            s[j] <- h$s
        }
        mu <- exp(m + s^2/2)
        omega <- exp(s^2)
        sigma <- sqrt(omega * (omega - 1)) * exp(m)
    }
    else {
        mu <- colMeans(xn, na.rm = TRUE)
        sigma <- sqrt(rowSums((t(xn) - mu)^2, na.rm = TRUE)/(nrow(xn) - 
            1))
    }
    alpha <- pmax(colMeans(xr, na.rm = TRUE) - mu, 10)
    cbind(mu = mu, logsigma = log(sigma), logalpha = log(alpha))
}
#$
\end{Soutput}
\subsubsection{La fonction normexp.signal() de limma :}
\begin{Sinput}
 normexp.signal
\end{Sinput}
\begin{Soutput}
function (par, x) 
{
    mu <- par[1]
    sigma <- exp(par[2])
    sigma2 <- sigma * sigma
    alpha <- exp(par[3])
    if (alpha <= 0) 
        stop("alpha must be positive")
    if (sigma <= 0) 
        stop("sigma must be positive")
    mu.sf <- x - mu - sigma2/alpha
    signal <- mu.sf + sigma2 * exp(dnorm(0, mean = mu.sf, sd = sigma, 
        log = TRUE) - pnorm(0, mean = mu.sf, sd = sigma, lower.tail = FALSE, 
        log.p = TRUE))
    o <- !is.na(signal)
    if (any(signal[o] < 0)) {
        warning("Limit of numerical accuracy reached with very low intensity 
        or very high background:\nsetting adjusted intensities to small value")
        signal[o] <- pmax(signal[o], 1e-06)
    }
    signal
}
\end{Soutput}
\end{Schunk}
\subsection{Analyse des données :}
\nocite{smyth2005limma}
\nocite{druaghici2016statistics}
\bibliographystyle{plain} 
\bibliography{rapport_Stage}
\end{document}          
